---------------------------------------------------------------------------------------------
The following form contains:
Opening: Text that can be replaced
Paragraph 1: Text that can be replaced 
Paragraph 2: Checkboxes that appear selected or unselected (only 1)
Paragraph 3: N/A
Paragraph 4: N/A
Paragraph 5: Paragraphs that can be shown or hidden
Paragraph 6: Table containing list of items
Paragraph 7: Paragraphs that can be shown or hidden, if shown - Table containing list of items
Closing: Checkboxes followed by optional paragraphs

---------------------------------------------------------------------------------------------
Describe which section of the form you think is important to automate:

1) Anything that could be prone to human error, and easy for system to validate.
This would include all the text insertions that could be misread during manual verification.

2) Anything that if processed incorrectly would cause the biggest problems for the client.
For instance, if there were still placeholder text within the document.

---------------------------------------------------------------------------------------------
Describe which section of the form you think is more efficient to do Manual test and why:

1) Something that could be hard for a system to populate or validate.
I would say this could include validating the signatures, or the checkboxes.
For example, the provided 'Then' step definition does not read 'x' for a checked box from my testing.
This would require additional work to automate, which is time consuming.
There is only a few checkboxes and handful of possible scenarios to test for.

2) Visually inspecting file is formatted correctly (i.e. input text wraps nicely in tables)

----------------------------------------------------------------------------------------------

Create 3 different scenarios using Gherkin language:

See test/resources/test.feature for my scenarios
I wanted coverage of text replacement, text insertion, and text removal
I've included both an Include and Deletion test for paragraph 5 to avoid a false positive
Prioritize the happy path big use cases customers need, and then add negative tests.

I learn best by coding things up and seeing them play out.
test/resources/data:
includes a basic sample schema so I could think about the types of inputs to expect

features/step_definitions/steps.js:
includes a When condition to experiment with ways document might get processed (text replacement)

test/resources/form:
includes the templates we may need to provide (e.g. 74B)

test/resources/result:
includes partially processed forms end results to check with my Then conditions.

One should swap out the code in When condition for something that sends the template and json to a system for processing.
I would want to see how I could levarage hooks (@Before, @After, @BeforeAll, @AfterAll) to reduce duplicate setup steps
